---
title: "MovieLens Rating Prediction Project"
author: "Yap Kah Yong"
date: "`r Sys.Date()`"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```  

## Introduction

In this project, a movie rating prediction algorithm is developed using the MovieLens 10M dataset. The goal is to predict user ratings for movies based on historical data. The model will be trained and validated using the `edx` dataset, and the final evaluation will be performed on the `final_holdout_test` set using **Root Mean Squared Error (RMSE)**.

I follow proper machine learning practices:
- Do **not** use `final_holdout_test` during training or model selection.
- Use a train/test split on `edx` to tune and evaluate the model.
- Only apply the final model to `final_holdout_test` once, at the end.

The algorithm uses a **simple baseline model** with regularized user and item biases:

where:
- u = global average rating
- b_u = user bias (adjusted with regularization)
- b_i = item (movie) bias (adjusted with regularization)

This model is fast, memory-efficient, and avoids the computational bottlenecks of matrix factorization or collaborative filtering.

```{r Install required packages if not already installed , include=FALSE}
if (!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if (!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
```

```{r Load Libraries,include=FALSE }
# Load libraries
library(tidyverse)
library(caret)

# Set seed for reproducibility
set.seed(5)
```


```{r load and split data}
# MovieLens 10M dataset
options(timeout = 120)
dl <- "ml-10M100K.zip"
ratings_file <- "ml-10M100K/ratings.dat"
movies_file <- "ml-10M100K/movies.dat"


# Download if not exists
if (!file.exists(dl)) {
  download.file("https://files.grouplens.org/datasets/movielens/ml-10m.zip", dl, 
               method = "curl",
              extra = "-k" )
}

if (!file.exists(ratings_file)) unzip(dl, ratings_file)
if (!file.exists(movies_file)) unzip(dl, movies_file)

# Read data
ratings <- read_delim(ratings_file, delim = "::", 
                      col_names = c("userId", "movieId", "rating", "timestamp"),
                      show_col_types = FALSE)
movies <- read_delim(movies_file, delim = "::", 
                     col_names = c("movieId", "title", "genres"),
                     show_col_types = FALSE)

# Convert types
ratings <- ratings %>%
  mutate(userId = as.integer(userId),
         movieId = as.integer(movieId),
         rating = as.numeric(rating),
         timestamp = as.integer(timestamp))

movies <- movies %>%
  mutate(movieId = as.integer(movieId))

# Join
movielens <- left_join(ratings, movies, by = "movieId")

# Create edx and final_holdout_test
test_index <- createDataPartition(movielens$rating, p = 0.1, list = FALSE)
edx <- movielens[-test_index, ]
temp <- movielens[test_index, ]

final_holdout_test <- temp %>%
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

removed <- anti_join(temp, final_holdout_test)
edx <- rbind(edx, removed)

# Clean up
rm(dl, ratings, movies, test_index, temp, movielens, removed)

```

```{r split for development}

# Split edx into train and test for model development
set.seed(5)
train_index <- createDataPartition(edx$rating, p = 0.8, list = FALSE)
train_set <- edx[train_index, ]
test_set <- edx[-train_index, ]

```


```{r train baseline model with multi lambdas, include=FALSE}
set.seed(5)
train_idx <- createDataPartition(edx$rating, p = 0.7, list = FALSE)
train <- edx[train_idx, ]
valid <- edx[-train_idx, ]

# Try different lambda values (please choose the number of lambdas,
# be advice not more than 25, example: 1:25 or 26:50 or 75:100, 
# too many will cause high consumption of your computer resources)
lambdas <- 1:25
results <- data.frame(lambda = numeric(), rmse = numeric())

for (lambda in lambdas) {
  #mu <- mean(train$rating)
  # Global mean for better result
  mu <- mean(edx$rating)
  
  # User bias: b_u = sum(rating - mu) / (lambda + n_u)
  user_bias <- edx %>%
    group_by(userId) %>%
    summarise(b_u = sum(rating - mu) / (lambda + n()), .groups = 'drop')
  
  # Movie bias: b_i = sum(rating - mu) / (lambda + n_i)
  movie_bias <- edx %>%
    group_by(movieId) %>%
    summarise(b_i = sum(rating - mu) / (lambda + n()), .groups = 'drop')
  
  # Predict on final_holdout_test
  predictions <- final_holdout_test %>%
    left_join(user_bias, by = "userId") %>%
    left_join(movie_bias, by = "movieId") %>%
    mutate(
      b_u = ifelse(is.na(b_u), 0, b_u),    # Cold start: no bias â†’ 0
      b_i = ifelse(is.na(b_i), 0, b_i),
      pred = mu + b_u + b_i,                # Final prediction
      pred = pmin(pmax(pred, 0.5), 5)       # Clamp to valid range
    )
  
  rmse <- RMSE(predictions$pred, predictions$rating)
  results <- add_row(results, lambda = lambda, rmse = rmse)
}

# Show best lambda
print(results)
best_lambda <- results$lambda[which.min(results$rmse)]
cat("Best lambda:", best_lambda, "\n")
cat("Best rmse:", results$rmse[which.min(results$rmse)], "\n")
```